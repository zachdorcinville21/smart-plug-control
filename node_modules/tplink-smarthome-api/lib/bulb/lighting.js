"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Lighting_lightState;
Object.defineProperty(exports, "__esModule", { value: true });
exports.isLightStateResponse = exports.isLightState = void 0;
const lodash_isequal_1 = __importDefault(require("lodash.isequal"));
const utils_1 = require("../utils");
function isLightState(candidate) {
    return (0, utils_1.isObjectLike)(candidate);
}
exports.isLightState = isLightState;
function isLightStateResponse(candidate) {
    return (0, utils_1.isObjectLike)(candidate) && (0, utils_1.hasErrCode)(candidate);
}
exports.isLightStateResponse = isLightStateResponse;
class Lighting {
    constructor(device, apiModuleName, setLightStateMethodName) {
        this.device = device;
        this.apiModuleName = apiModuleName;
        this.setLightStateMethodName = setLightStateMethodName;
        /**
         * @internal
         */
        this.lastState = {
            powerOn: undefined,
            lightState: undefined,
        };
        /**
         * @internal
         */
        _Lighting_lightState.set(this, {});
    }
    /**
     * Returns cached results from last retrieval of `lightingservice.get_light_state`.
     * @returns cached results from last retrieval of `lightingservice.get_light_state`.
     */
    get lightState() {
        return __classPrivateFieldGet(this, _Lighting_lightState, "f");
    }
    /**
     * @internal
     */
    set lightState(lightState) {
        __classPrivateFieldSet(this, _Lighting_lightState, lightState, "f");
        this.emitEvents();
    }
    emitEvents() {
        if (!__classPrivateFieldGet(this, _Lighting_lightState, "f"))
            return;
        const powerOn = __classPrivateFieldGet(this, _Lighting_lightState, "f").on_off === 1;
        if (this.lastState.powerOn !== powerOn) {
            if (powerOn) {
                this.device.emit('lightstate-on', __classPrivateFieldGet(this, _Lighting_lightState, "f"));
            }
            else {
                this.device.emit('lightstate-off', __classPrivateFieldGet(this, _Lighting_lightState, "f"));
            }
        }
        if (!(0, lodash_isequal_1.default)(this.lastState.lightState, __classPrivateFieldGet(this, _Lighting_lightState, "f"))) {
            this.device.emit('lightstate-change', __classPrivateFieldGet(this, _Lighting_lightState, "f"));
        }
        this.device.emit('lightstate-update', __classPrivateFieldGet(this, _Lighting_lightState, "f"));
        this.lastState.powerOn = powerOn;
        this.lastState.lightState = __classPrivateFieldGet(this, _Lighting_lightState, "f");
    }
    /**
     * Get Bulb light state.
     *
     * Requests `lightingservice.get_light_state`.
     * @returns parsed JSON response
     * @throws {@link ResponseError}
     */
    async getLightState(sendOptions) {
        this.lightState = (0, utils_1.extractResponse)(await this.device.sendCommand({
            [this.apiModuleName]: { get_light_state: {} },
        }, undefined, sendOptions), '', isLightStateResponse);
        return this.lightState;
    }
    /**
     * Sets Bulb light state (on/off, brightness, color, etc).
     *
     * Sends `lightingservice.transition_light_state` command.
     * @param  lightState - light state
     * @param  sendOptions - send options
     */
    async setLightState(lightState, sendOptions) {
        const { 
        /* eslint-disable @typescript-eslint/naming-convention */
        transition_period, on_off, mode, hue, saturation, brightness, color_temp, ignore_default = 1,
        /* eslint-enable @typescript-eslint/naming-convention */
         } = lightState;
        const state = {};
        if ((0, utils_1.isDefinedAndNotNull)(ignore_default))
            state.ignore_default = ignore_default ? 1 : 0;
        if ((0, utils_1.isDefinedAndNotNull)(transition_period))
            state.transition_period = transition_period;
        if ((0, utils_1.isDefinedAndNotNull)(on_off))
            state.on_off = on_off ? 1 : 0;
        if ((0, utils_1.isDefinedAndNotNull)(mode))
            state.mode = mode;
        if ((0, utils_1.isDefinedAndNotNull)(hue))
            state.hue = hue;
        if ((0, utils_1.isDefinedAndNotNull)(saturation))
            state.saturation = saturation;
        if ((0, utils_1.isDefinedAndNotNull)(brightness))
            state.brightness = brightness;
        if ((0, utils_1.isDefinedAndNotNull)(color_temp))
            state.color_temp = color_temp;
        const response = (0, utils_1.extractResponse)(await this.device.sendCommand({
            [this.apiModuleName]: { [this.setLightStateMethodName]: state },
        }, undefined, sendOptions), '', isLightStateResponse);
        // The light strip in particular returns more detail with get(), so only
        // apply the subset that is returned with set()
        this.lightState = { ...this.lightState, ...response };
        return true;
    }
    /**
     * Get Bulb light details.
     *
     * Requests `lightingservice.get_light_details`.
     * @returns parsed JSON response
     * @throws {@link ResponseError}
     */
    async getLightDetails(sendOptions) {
        return this.device.sendCommand({
            [this.apiModuleName]: { get_light_details: {} },
        }, undefined, sendOptions);
    }
}
exports.default = Lighting;
_Lighting_lightState = new WeakMap();
//# sourceMappingURL=lighting.js.map