"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Emeter_realtime;
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRealtime = void 0;
const utils_1 = require("../utils");
function isRealtime(candidate) {
    return (0, utils_1.isObjectLike)(candidate);
}
exports.isRealtime = isRealtime;
class Emeter {
    constructor(device, apiModuleName, childId = undefined) {
        this.device = device;
        this.apiModuleName = apiModuleName;
        this.childId = childId;
        _Emeter_realtime.set(this, {});
    }
    /**
     * Returns cached results from last retrieval of `emeter.get_realtime`.
     * @returns {Object}
     */
    get realtime() {
        return __classPrivateFieldGet(this, _Emeter_realtime, "f");
    }
    /**
     * @private
     */
    setRealtime(realtime) {
        const normRealtime = { ...realtime }; // will coerce null/undefined to {}
        const normalize = (key1, key2, multiplier) => {
            const r = normRealtime;
            if (typeof r[key1] === 'number' && r[key2] === undefined) {
                r[key2] = Math.floor(r[key1] * multiplier);
            }
            else if (r[key1] == null && typeof r[key2] === 'number') {
                r[key1] = r[key2] / multiplier;
            }
        };
        if (realtime != null) {
            normalize('current', 'current_ma', 1000);
            normalize('power', 'power_mw', 1000);
            normalize('total', 'total_wh', 1000);
            normalize('voltage', 'voltage_mv', 1000);
        }
        __classPrivateFieldSet(this, _Emeter_realtime, normRealtime, "f");
        this.device.emit('emeter-realtime-update', __classPrivateFieldGet(this, _Emeter_realtime, "f"));
    }
    /**
     * Gets device's current energy stats.
     *
     * Requests `emeter.get_realtime`. Older devices return `current`, `voltage`, etc,
     * while newer devices return `current_ma`, `voltage_mv` etc
     * This will return a normalized response including both old and new style properties for backwards compatibility.
     * Supports childId.
     * @param   sendOptions
     * @returns parsed JSON response
     * @throws {@link ResponseError}
     */
    async getRealtime(sendOptions) {
        this.setRealtime((0, utils_1.extractResponse)(await this.device.sendCommand({
            [this.apiModuleName]: { get_realtime: {} },
        }, this.childId, sendOptions), '', (c) => isRealtime(c) && (0, utils_1.hasErrCode)(c)));
        return this.realtime;
    }
    /**
     * Get Daily Emeter Statistics.
     *
     * Sends `emeter.get_daystat` command. Supports childId.
     * @param   year
     * @param   month
     * @param   sendOptions
     * @returns parsed JSON response
     * @throws {@link ResponseError}
     */
    async getDayStats(year, month, sendOptions) {
        return this.device.sendCommand({
            [this.apiModuleName]: { get_daystat: { year, month } },
        }, this.childId, sendOptions);
    }
    /**
     * Get Monthly Emeter Statistics.
     *
     * Sends `emeter.get_monthstat` command. Supports childId.
     * @param   year
     * @param   sendOptions
     * @returns parsed JSON response
     * @throws {@link ResponseError}
     */
    async getMonthStats(year, sendOptions) {
        return this.device.sendCommand({
            [this.apiModuleName]: { get_monthstat: { year } },
        }, this.childId, sendOptions);
    }
    /**
     * Erase Emeter Statistics.
     *
     * Sends `emeter.erase_runtime_stat` command. Supports childId.
     * @param   sendOptions
     * @returns parsed JSON response
     * @throws {@link ResponseError}
     */
    async eraseStats(sendOptions) {
        return this.device.sendCommand({
            [this.apiModuleName]: { erase_emeter_stat: {} },
        }, this.childId, sendOptions);
    }
}
exports.default = Emeter;
_Emeter_realtime = new WeakMap();
//# sourceMappingURL=emeter.js.map